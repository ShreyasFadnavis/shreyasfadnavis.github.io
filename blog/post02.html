<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Conformal Prediction: The Distribution-Free Guarantee You Didn't Know Existed — Shreyas Fadnavis</title>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"
    onload="renderMathInElement(document.body, {delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}]});"></script>
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
  <script>mermaid.initialize({startOnLoad: true, theme: 'base', themeVariables: {primaryColor: '#f3f0ec', primaryTextColor: '#1c1917', primaryBorderColor: '#a0522d', lineColor: '#a0522d', secondaryColor: '#faf8f5', tertiaryColor: '#e5e0da'}});</script>
</head>
<body>

<nav>
  <div class="nav-inner">
    <a href="/" class="site-name">Shreyas Fadnavis</a>
    <div class="nav-links">
      <a href="/">About</a>
      <a href="/blog/" class="active">Notes</a>
    </div>
  </div>
</nav>

<main>
  <article class="post">
    <div class="post-header">
      <h1>Conformal Prediction: The Distribution-Free Guarantee You Didn't Know Existed</h1>
      <p class="post-subtitle">Part 2 of a 10-part series on prediction intervals, conformal prediction, and leverage scores.</p>
    </div>

    <div class="series-banner">
      This is part of the series <a href="/blog/">From Predictions to Prediction Intervals</a>.
      <a href="post01.html" class="prev">Your Model Is Confident</a>
      <a href="post03.html" class="next">The Constant-Width Problem</a>
    </div>

    <div class="post-body">

      <p>In Part 1, we argued that point predictions are incomplete. What we need are prediction intervals with <em>guaranteed</em> coverage: if we claim 90%, then 90% of future observations should fall inside. We also want this guarantee to hold without assuming Gaussian errors, linear models, or any parametric form.</p>

      <p>This sounds like a tall order. It turns out there is a clean, simple method that delivers exactly this. It is called <em>conformal prediction</em>, and it has been around since 2005, though it has only recently gained widespread attention in the machine learning community.</p>

      <p>This post walks through conformal prediction at three levels of depth. Start wherever feels comfortable and go as deep as you like.</p>

      <!-- ====================================================== -->
      <!-- LEVEL 1: INTUITIVE                                      -->
      <!-- ====================================================== -->
      <div class="level">
        <div class="level-header" role="button" aria-expanded="true" onclick="this.parentElement.querySelector('.level-content').classList.toggle('collapsed'); this.setAttribute('aria-expanded', this.getAttribute('aria-expanded')==='true'?'false':'true');">
          <span class="level-badge intuitive">Intuitive</span>
          <h2>The Big Idea, No Math Required</h2>
          <span class="level-toggle">&#9660;</span>
        </div>
        <div class="level-content">

          <h3>A Restaurant Analogy</h3>

          <p>Imagine you go to a restaurant with nine friends. Everyone orders, and eventually all ten meals arrive. You have no idea what anyone ordered or what anything costs. But here is something you <em>can</em> say: the meals arrive in a random order, and each person's meal is equally likely to be the most expensive, the second most expensive, and so on. There is no seating hierarchy, no "VIP gets served first" rule. Every diner is interchangeable.</p>

          <p>Now suppose you want to know: "Will my meal cost less than the 9th most expensive meal out of all ten?" Since your meal's <em>rank</em> among all ten is random, the probability that your meal ranks 9th or lower is 9 out of 10, which is 90%. You did not need to know the prices, the menu, or the cuisine. You just needed to know that the ordering was random. The specific dollar amounts are irrelevant; all that matters is the ranking.</p>

          <p>That is the core of conformal prediction. Replace "meals" with "prediction errors," and "cost" with "how wrong the model was," and you have the whole idea. The method works because a new data point has no reason to produce a larger or smaller error than any calibration point, so its rank is uniformly random.</p>

          <div class="analogy">
            <div class="analogy-label">Analogy</div>
            <p>Conformal prediction is like grading on a curve. You do not need to know how hard the exam was or what material it covered. You just need to know where you rank among everyone else. If your score's rank is random, you can make reliable probability statements about where it will fall. The absolute difficulty of the test washes out; only the relative ordering matters.</p>
          </div>

          <h3>The Recipe in Plain English</h3>

          <p>Here is the conformal prediction recipe, with no equations:</p>

          <ol>
            <li><strong>Train any model.</strong> Linear regression, random forest, neural network, anything. The conformal procedure is completely agnostic to the model you choose.</li>
            <li><strong>Set aside some data the model never saw.</strong> Call this the "calibration set." The model was not trained on it. This held-out data serves as a reality check on how the model actually performs.</li>
            <li><strong>Check how wrong the model is on each calibration point.</strong> For each held-out data point, compute the size of the error: how far off was the prediction? These errors are your raw material for building the interval.</li>
            <li><strong>Sort those errors and pick the 90th percentile.</strong> This becomes your "margin of error." It tells you: 90% of the calibration points had errors no larger than this value.</li>
            <li><strong>For any new prediction, add and subtract that margin.</strong> That is your 90% prediction interval. The interval is symmetric around the point prediction and has the same width everywhere.</li>
          </ol>

          <div class="mermaid">
graph LR
    A["All Data"] --> B["Training Set"]
    A --> C["Calibration Set"]
    B --> D["Train Any Model"]
    D --> E["Predict on<br/>Calibration Set"]
    C --> E
    E --> F["Compute Errors:<br/>|actual - predicted|"]
    F --> G["Sort Errors &<br/>Pick 90th Percentile"]
    G --> H["Use as Margin<br/>for New Predictions"]
          </div>
          <p class="diagram-caption">The split conformal prediction pipeline in five steps.</p>

          <h3>Why Does This Work?</h3>

          <p>The key insight is that a new test point is "just another data point." If the data are all drawn from the same process and no point is special, then the new point's error has no reason to be systematically bigger or smaller than the calibration errors. Its rank among all the errors is random, just like your meal's rank among the restaurant bills. The model might be good or bad overall, but that does not affect the argument. What matters is symmetry: the new point is exchangeable with the calibration points.</p>

          <p>So if you set the threshold at the 90th percentile, the new point's error will fall below that threshold at least 90% of the time. A better model will produce smaller calibration errors, which leads to a smaller threshold and tighter intervals. But the coverage guarantee holds regardless of model quality.</p>

          <h3>What the Calibration Errors Look Like</h3>

          <div class="mermaid">
graph TD
    subgraph errors["Calibration Errors (sorted, smallest to largest)"]
        direction LR
        E1["0.3"] --- E2["0.5"] --- E3["0.8"] --- E4["1.1"] --- E5["1.4"]
        E5 --- E6["1.7"] --- E7["2.0"] --- E8["2.3"] --- E9["2.8"] --- E10["3.5"]
    end
    E9 -. "90th percentile<br/>threshold = 2.8" .-> T["Use 2.8 as margin<br/>of error for new predictions"]
    style E9 fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px
    style T fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px
          </div>
          <p class="diagram-caption">Ten calibration errors sorted in order. The 90th percentile (2.8) becomes the interval half-width.</p>

          <p>The model predicts, say, 50 for a new data point. Your 90% prediction interval is [50 - 2.8, 50 + 2.8] = [47.2, 52.8].</p>

          <h3>The One Assumption</h3>

          <div class="callout">
            <div class="callout-label">Key Assumption</div>
            <p>The only assumption conformal prediction makes is that the data are <strong>exchangeable</strong>: roughly, any reordering of the data points is equally likely. This is weaker than "independent and identically distributed." It means no data point is special by virtue of when it was observed.</p>
          </div>

          <p>If you have a standard supervised learning setup where you collect data, shuffle it, and split it into training and test sets, exchangeability holds automatically. It can fail for time series (where order matters) or when the data distribution shifts over time. In practice, the assumption amounts to: the process generating the calibration data is the same process that will generate the test data. If that holds, you are in good shape.</p>

          <h3>Why This Matters</h3>

          <p>Conformal prediction gives you a guaranteed prediction interval that works with <em>any</em> model. You do not need to know the error distribution, you do not need Gaussian assumptions, and you do not need the model to be linear. You just need the calibration data, a sorting algorithm, and the exchangeability assumption. That is it. Most other methods for building prediction intervals require either strong distributional assumptions or asymptotic arguments that may not hold in practice. Conformal prediction sidesteps both of these issues entirely.</p>

        </div>
      </div>

      <!-- ====================================================== -->
      <!-- LEVEL 2: TECHNICAL                                      -->
      <!-- ====================================================== -->
      <div class="level">
        <div class="level-header" role="button" aria-expanded="true" onclick="this.parentElement.querySelector('.level-content').classList.toggle('collapsed'); this.setAttribute('aria-expanded', this.getAttribute('aria-expanded')==='true'?'false':'true');">
          <span class="level-badge technical">Technical</span>
          <h2>The Split Conformal Recipe, Formally</h2>
          <span class="level-toggle">&#9660;</span>
        </div>
        <div class="level-content">

          <h3>Setup</h3>

          <p>We have $n$ data points $(X_i, Y_i)$ drawn exchangeably. We choose a desired coverage level $1 - \alpha$ (e.g., $1 - \alpha = 0.9$ for 90% coverage). We have access to any prediction model.</p>

          <h3>Step 1: Split</h3>

          <p>Divide the data into a <strong>training set</strong> $D_1$ of size $n_1$ and a <strong>calibration set</strong> $D_2$ of size $n_2$. These must be disjoint. The split can be done at random.</p>

          <h3>Step 2: Train</h3>

          <p>Fit a prediction model $\hat{f}$ on $D_1$. This can be OLS, a random forest, a neural network, an ensemble, or anything else. The method imposes no constraint on the model class.</p>

          <h3>Step 3: Calibrate</h3>

          <p>For each calibration point $(X_i, Y_i) \in D_2$, compute the <em>nonconformity score</em> (here, just the absolute residual):</p>

          $$S_i = |Y_i - \hat{f}(X_i)|, \quad i = 1, \ldots, n_2$$

          <p>Sort these scores. Define the <em>conformal quantile</em>:</p>

          $$\hat{q} = S_{(\lceil(1-\alpha)(n_2+1)\rceil)}$$

          <p>where $S_{(k)}$ denotes the $k$-th smallest score.</p>

          <h3>Step 4: Predict</h3>

          <p>For a new test point $x$, the prediction interval is:</p>

          $$\hat{C}(x) = \left[\hat{f}(x) - \hat{q}, \;\; \hat{f}(x) + \hat{q}\right]$$

          <div class="mermaid">
graph TB
    A["Data: (X₁,Y₁), ..., (Xₙ,Yₙ)"]
    A -->|"Random split"| B["D₁: Training Set<br/>(n₁ points)"]
    A -->|"Random split"| C["D₂: Calibration Set<br/>(n₂ points)"]
    B --> D["Train model f̂ on D₁"]
    D --> E["Compute scores on D₂:<br/>Sᵢ = |Yᵢ - f̂(Xᵢ)|"]
    C --> E
    E --> F["Sort scores, take<br/>k = ⌈(1-α)(n₂+1)⌉-th smallest"]
    F --> G["q̂ = S₍ₖ₎"]
    G --> H["Interval for new x:<br/>[f̂(x) - q̂, f̂(x) + q̂]"]
    style H fill:#e3f2fd,stroke:#1565c0,stroke-width:2px
          </div>
          <p class="diagram-caption">The full split conformal pipeline with formulas at each step.</p>

          <h3>The Coverage Guarantee</h3>

          <p>The notable property of this procedure is a finite-sample coverage guarantee:</p>

          $$P\!\left(Y_{n+1} \in \hat{C}(X_{n+1})\right) \geq 1 - \alpha$$

          <p>This holds for any sample size $n_2$, any model $\hat{f}$, and any data distribution. The only requirement is that the calibration points and the test point are exchangeable.</p>

          <h3>What Is Exchangeability?</h3>

          <p>A sequence of random variables $Z_1, \ldots, Z_n$ is <strong>exchangeable</strong> if for every permutation $\pi$:</p>

          $$(Z_1, \ldots, Z_n) \stackrel{d}{=} (Z_{\pi(1)}, \ldots, Z_{\pi(n)})$$

          <p>In words: the joint distribution does not change if you reorder the data. Any iid sample is automatically exchangeable, but exchangeability is strictly weaker: it allows some forms of dependence (for example, drawing from a random distribution, then sampling iid from it).</p>

          <div class="mermaid">
graph TD
    subgraph perm1["Ordering 1"]
        P1["Z₁, Z₂, Z₃"]
    end
    subgraph perm2["Ordering 2"]
        P2["Z₃, Z₁, Z₂"]
    end
    subgraph perm3["Ordering 3"]
        P3["Z₂, Z₃, Z₁"]
    end
    perm1 -.- EQ["All have the<br/>SAME joint distribution"]
    perm2 -.- EQ
    perm3 -.- EQ
    style EQ fill:#e3f2fd,stroke:#1565c0,stroke-width:2px
          </div>
          <p class="diagram-caption">Exchangeability: every permutation of the data has the same joint distribution.</p>

          <h3>The "+1" in the Quantile</h3>

          <p>Why do we compute $\lceil(1-\alpha)(n_2 + 1)\rceil$ rather than $\lceil(1-\alpha) n_2\rceil$? The "+1" accounts for the test point. There are $n_2$ calibration scores and 1 test score, for a total of $n_2 + 1$ scores. By exchangeability, the test score's rank among all $n_2 + 1$ scores is uniformly distributed. The probability that it falls at or below rank $k$ is exactly $k / (n_2 + 1)$.</p>

          <p>Setting $k = \lceil(1-\alpha)(n_2+1)\rceil$ ensures this probability is at least $1-\alpha$.</p>

          <p><strong>Concrete example:</strong> With $\alpha = 0.1$ and $n_2 = 500$:</p>

          $$k = \lceil 0.9 \times 501 \rceil = \lceil 450.9 \rceil = 451$$

          <p>So $\hat{q}$ is the 451st smallest residual out of 500. The actual coverage is $451/501 \approx 0.9002$, slightly above the nominal 90%.</p>

          <h3>Summary of Properties</h3>

          <table>
            <thead>
              <tr>
                <th>Property</th>
                <th>What It Means</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Finite-sample</strong></td>
                <td>Not asymptotic. Holds for any calibration set size $n_2$.</td>
              </tr>
              <tr>
                <td><strong>Distribution-free</strong></td>
                <td>No parametric assumptions on the data distribution.</td>
              </tr>
              <tr>
                <td><strong>Model-agnostic</strong></td>
                <td>Works with any prediction model: linear, tree-based, neural, anything.</td>
              </tr>
              <tr>
                <td><strong>Computationally trivial</strong></td>
                <td>After training, the only cost is sorting $n_2$ numbers.</td>
              </tr>
            </tbody>
          </table>

          <h3>What the Guarantee Does NOT Give You</h3>

          <p>The coverage guarantee is <strong>marginal</strong>: it averages over all possible test points and all randomness in the calibration set. It says nothing about coverage at any <em>specific</em> test point $x$.</p>

          <p>If the model is very accurate in one region of feature space and very inaccurate in another, the interval will overcover in the easy region and undercover in the hard region. The average will be correct, but the per-point coverage can vary substantially. For example, if the model fits dense regions well but struggles with sparse, high-leverage regions, the constant-width interval will be wastefully wide in the dense region and too narrow in the sparse region.</p>

          <div class="callout">
            <div class="callout-label">Teaser for Post 3</div>
            <p>This is the <strong>constant-width problem</strong>. Vanilla conformal prediction produces intervals of the same width everywhere, regardless of local difficulty. The next post shows why this is a fundamental limitation and what can be done about it.</p>
          </div>

        </div>
      </div>

      <!-- ====================================================== -->
      <!-- LEVEL 3: ADVANCED                                       -->
      <!-- ====================================================== -->
      <div class="level">
        <div class="level-header" role="button" aria-expanded="true" onclick="this.parentElement.querySelector('.level-content').classList.toggle('collapsed'); this.setAttribute('aria-expanded', this.getAttribute('aria-expanded')==='true'?'false':'true');">
          <span class="level-badge advanced">Advanced</span>
          <h2>The Proof and Its Extensions</h2>
          <span class="level-toggle">&#9660;</span>
        </div>
        <div class="level-content">

          <h3>Formal Exchangeability</h3>

          <p>A random vector $(Z_1, \ldots, Z_n)$ taking values in $\mathcal{Z}^n$ is <strong>exchangeable</strong> if for every permutation $\pi$ on $\{1, \ldots, n\}$:</p>

          $$(Z_1, \ldots, Z_n) \stackrel{d}{=} (Z_{\pi(1)}, \ldots, Z_{\pi(n)})$$

          <p>This is equivalent to saying the joint density (or mass function) $f(z_1, \ldots, z_n)$ is a symmetric function of its arguments. De Finetti's theorem says that an infinite exchangeable sequence is equivalent to an iid mixture: there exists a random distribution $\Theta$ such that, conditional on $\Theta$, the $Z_i$ are iid from $\Theta$.</p>

          <h3>The Rank Uniformity Lemma</h3>

          <p>The following result, due to Vovk, Gammerman, and Shafer (2005), is the backbone of conformal prediction.</p>

          <p><strong>Lemma.</strong> Let $Z_1, \ldots, Z_{n+1}$ be exchangeable random variables. Define the rank of $Z_{n+1}$ among all $n+1$ values as:</p>

          $$R_{n+1} = \sum_{i=1}^{n+1} \mathbf{1}\{Z_i \leq Z_{n+1}\}$$

          <p>Then $R_{n+1}$ is uniformly distributed on $\{1, 2, \ldots, n+1\}$.</p>

          <h3>Proof Sketch</h3>

          <p>By exchangeability, the joint distribution of $(Z_1, \ldots, Z_{n+1})$ is invariant under permutations. Consider any fixed value $k \in \{1, \ldots, n+1\}$. The event $\{R_{n+1} = k\}$ (i.e., $Z_{n+1}$ has rank $k$) can be mapped by a permutation to the event $\{R_{j} = k\}$ for any $j$. Since the distribution is invariant under this permutation:</p>

          $$P(R_{n+1} = k) = P(R_j = k) \quad \text{for all } j \in \{1, \ldots, n+1\}$$

          <p>Summing over $j$:</p>

          $$\sum_{j=1}^{n+1} P(R_j = k) = (n+1) \cdot P(R_{n+1} = k)$$

          <p>But $\sum_{j=1}^{n+1} P(R_j = k) = 1$, because exactly one of the $n+1$ values has rank $k$ (assuming distinct values almost surely, which can be handled by randomized tie-breaking in general). Therefore:</p>

          $$P(R_{n+1} = k) = \frac{1}{n+1}$$

          <p>This is the rank uniformity result. It is a direct consequence of symmetry, nothing more. No moment conditions, no tail assumptions, and no regularity conditions on the distribution are needed. The entire argument rests on the single observation that exchangeability makes every index equally likely to hold any given rank.</p>

          <div class="mermaid">
graph TB
    A["Exchangeability:<br/>(Z₁,...,Zₙ₊₁) is permutation-invariant"]
    A --> B["Rank of Zₙ₊₁ has<br/>same distribution as rank of Zⱼ<br/>for any j"]
    B --> C["Exactly one Zⱼ has rank k<br/>=> sum of P(Rⱼ=k) over j = 1"]
    C --> D["(n+1) · P(Rₙ₊₁=k) = 1"]
    D --> E["P(Rₙ₊₁=k) = 1/(n+1)<br/>Rank is uniform on {1,...,n+1}"]
    E --> F["Setting k = ⌈(1-α)(n+1)⌉:<br/>P(Zₙ₊₁ ≤ Z₍ₖ₎) ≥ 1-α"]
    style E fill:#fce4ec,stroke:#c62828,stroke-width:2px
    style F fill:#fce4ec,stroke:#c62828,stroke-width:2px
          </div>
          <p class="diagram-caption">The proof flow: from exchangeability to the coverage guarantee in four steps.</p>

          <h3>From Rank Uniformity to Coverage</h3>

          <p>Apply the lemma with $Z_i = S_i = |Y_i - \hat{f}(X_i)|$ for the calibration points and $Z_{n_2+1} = S_{n_2+1} = |Y_{n+1} - \hat{f}(X_{n+1})|$ for the test point. Conditional on $D_1$ (which determines $\hat{f}$), the scores $S_1, \ldots, S_{n_2}, S_{n_2+1}$ are exchangeable. By the lemma, the rank of $S_{n_2+1}$ is uniform on $\{1, \ldots, n_2+1\}$.</p>

          <p>The event $Y_{n+1} \in \hat{C}(X_{n+1})$ is equivalent to $S_{n_2+1} \leq \hat{q} = S_{(k)}$ where $k = \lceil(1-\alpha)(n_2+1)\rceil$. The probability of this event is:</p>

          $$P(S_{n_2+1} \leq S_{(k)}) = P(R_{n_2+1} \leq k) = \frac{k}{n_2+1} \geq \frac{\lceil(1-\alpha)(n_2+1)\rceil}{n_2+1} \geq 1 - \alpha$$

          <h3>Upper Bound on Coverage</h3>

          <p>The coverage is also bounded above. Since $k = \lceil(1-\alpha)(n_2+1)\rceil \leq (1-\alpha)(n_2+1) + 1$:</p>

          $$P(Y_{n+1} \in \hat{C}(X_{n+1})) = \frac{k}{n_2+1} \leq \frac{(1-\alpha)(n_2+1) + 1}{n_2+1} = 1 - \alpha + \frac{1}{n_2 + 1}$$

          <p>So the coverage lies in the interval $[1-\alpha, \; 1-\alpha + 1/(n_2+1)]$. As $n_2 \to \infty$, the coverage converges to $1-\alpha$ exactly. For $n_2 = 500$, the overshoot is at most $1/501 \approx 0.002$, which is negligible.</p>

          <h3>When Exchangeability Fails</h3>

          <p>The coverage guarantee is <em>exact</em> under exchangeability. When exchangeability is violated, the guarantee degrades. The main failure modes are:</p>

          <ul>
            <li><strong>Time series:</strong> Temporal dependence means earlier observations are not interchangeable with later ones. The distribution may drift, making calibration residuals from the past unrepresentative of future errors. For instance, if volatility increases over time, calibration errors from a calm period will systematically underestimate future errors.</li>
            <li><strong>Distribution shift:</strong> If the test distribution differs from the calibration distribution (covariate shift, label shift, concept drift), the rank argument breaks down because the test score is no longer "just another one" from the same distribution. A model calibrated on data from one hospital, for example, may produce misleading intervals when deployed at a different hospital with a different patient population.</li>
            <li><strong>Active learning:</strong> If the sampling mechanism depends on previously observed labels, the resulting sample is not exchangeable. The selection process introduces a dependence between which points are observed and what their labels are, violating the symmetry that the proof requires.</li>
          </ul>

          <p>Extensions exist for some of these settings. Adaptive conformal inference (Gibbs and Candes, 2021) handles distribution shift by updating the quantile online. Weighted conformal prediction (Tibshirani et al., 2019) handles covariate shift by reweighting calibration scores. These are beyond our scope here, but they demonstrate that the conformal framework is extensible.</p>

          <h3>Connection to Permutation Tests</h3>

          <p>The rank uniformity argument underlying conformal prediction is the same argument that underlies permutation tests and rank-based nonparametric inference. In a permutation test, you compute a test statistic and ask: "Under the null hypothesis that the labels are exchangeable, what fraction of label permutations produce a test statistic at least this extreme?" The fraction gives you a p-value.</p>

          <p>Conformal prediction inverts this logic. Instead of testing whether a specific value is consistent with the data, it constructs the set of <em>all</em> values that <em>would be</em> consistent. This inversion of a permutation test into a confidence set is the intellectual origin of the name "conformal": the prediction set "conforms" to the data.</p>

          <div class="callout">
            <div class="callout-label">Historical Note</div>
            <p>The connection between prediction sets and permutation tests dates back to the work of Vovk, Gammerman, and Shafer in the early 2000s. The original "full conformal" method literally ran a permutation test for every candidate label value. Split conformal prediction, introduced by Papadopoulos et al. (2002) and analyzed by Lei et al. (2018), avoids this computational burden by using a held-out calibration set, trading a small amount of statistical efficiency for large computational savings.</p>
          </div>

        </div>
      </div>

    </div>

    <div class="further-reading">
      <h3>Further Reading</h3>
      <ul>
        <li>Vovk, V., Gammerman, A., &amp; Shafer, G. (2005). <em>Algorithmic Learning in a Random World.</em> Springer.</li>
        <li>Lei, J., G'Sell, M., Rinaldo, A., Tibshirani, R. J., &amp; Wasserman, L. (2018). Distribution-free predictive inference for regression. <em>Journal of the American Statistical Association</em>, 113(523), 1094-1111.</li>
        <li>Shafer, G. &amp; Vovk, V. (2008). A tutorial on conformal prediction. <em>Journal of Machine Learning Research</em>, 9, 371-421.</li>
      </ul>
    </div>

    <div class="post-nav">
      <a href="post01.html" class="prev">Your Model Is Confident</a>
      <a href="post03.html" class="next">The Constant-Width Problem</a>
    </div>

  </article>
</main>

<footer>
  <span>Shreyas Fadnavis</span>
  <span><a href="/blog/">Notes</a></span>
</footer>

<script src="../js/lightbox.js"></script>
</body>
</html>
